<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `zeroize` crate."><meta name="keywords" content="rust, rustlang, rust-lang, zeroize"><title>zeroize - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../zeroize/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Crate zeroize</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all zeroize's items</p></a><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'zeroize', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/zeroize/lib.rs.html#1-578' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>zeroize</a></span></h1><div class='docblock'><p>Securely zero memory with a simple trait (<a href="https://docs.rs/zeroize/latest/zeroize/trait.Zeroize.html">Zeroize</a>) built on stable Rust
primitives which guarantee the operation will not be &quot;optimized away&quot;.</p>
<h2 id="about" class="section-header"><a href="#about">About</a></h2>
<p><a href="http://www.daemonology.net/blog/2014-09-04-how-to-zero-a-buffer.html">Zeroing memory securely is hard</a> - compilers optimize for performance, and
in doing so they love to &quot;optimize away&quot; unnecessary zeroing calls. There are
many documented &quot;tricks&quot; to attempt to avoid these optimizations and ensure
that a zeroing routine is performed reliably.</p>
<p>This crate isn't about tricks: it uses <a href="https://doc.rust-lang.org/core/ptr/fn.write_volatile.html">core::ptr::write_volatile</a>
and <a href="https://doc.rust-lang.org/stable/core/sync/atomic/index.html">core::sync::atomic</a> memory fences to provide easy-to-use, portable
zeroing behavior which works on all of Rust's core number types and slices
thereof, implemented in pure Rust with no usage of FFI or assembly.</p>
<ul>
<li>No insecure fallbacks!</li>
<li>No dependencies!</li>
<li>No FFI or inline assembly! <strong>WASM friendly</strong> (and tested)!</li>
<li><code>#![no_std]</code> i.e. <strong>embedded-friendly</strong>!</li>
<li>No functionality besides securely zeroing memory!</li>
</ul>
<h2 id="usage" class="section-header"><a href="#usage">Usage</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">zeroize</span>::<span class="ident">Zeroize</span>;

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="comment">// Protip: don&#39;t embed secrets in your source code.</span>
    <span class="comment">// This is just an example.</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">secret</span> <span class="op">=</span> <span class="string">b&quot;Air shield password: 1,2,3,4,5&quot;</span>.<span class="ident">to_vec</span>();
    <span class="comment">// [ ... ] open the air shield here</span>

    <span class="comment">// Now that we&#39;re done using the secret, zero it out.</span>
    <span class="ident">secret</span>.<span class="ident">zeroize</span>();
}</pre></div>
<p>The <a href="https://docs.rs/zeroize/latest/zeroize/trait.Zeroize.html">Zeroize</a> trait is impl'd on all of Rust's core scalar types including
integers, floats, <code>bool</code>, and <code>char</code>.</p>
<p>Additionally, it's implemented on slices and <code>IterMut</code>s of the above types.</p>
<p>When the <code>std</code> feature is enabled (which it is by default), it's also impl'd
for <code>Vec</code>s of the above types as well as <code>String</code>, where it provides
<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.clear">Vec::clear()</a> / <a href="https://doc.rust-lang.org/std/string/struct.String.html#method.clear">String::clear()</a>-like behavior (truncating to zero-length)
but ensures the backing memory is securely zeroed with some caveats.
(NOTE: see &quot;Stack/Heap Zeroing Notes&quot; for important <code>Vec</code>/<code>String</code> details)</p>
<p>The <a href="https://docs.rs/zeroize/latest/zeroize/trait.DefaultIsZeroes.html">DefaultIsZeroes</a> marker trait can be impl'd on types which also
impl <a href="https://doc.rust-lang.org/std/default/trait.Default.html">Default</a>, which implements <a href="https://docs.rs/zeroize/latest/zeroize/trait.Zeroize.html">Zeroize</a> by overwriting a value with
the default value.</p>
<h2 id="custom-derive-support" class="section-header"><a href="#custom-derive-support">Custom Derive Support</a></h2>
<p>This crate has custom derive support for the <code>Zeroize</code> trait, which
automatically calls <code>zeroize()</code> on all members of a struct or tuple struct,
and adds a <code>Drop</code> impl which calls <code>zeroize()</code> when the item is dropped:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">zeroize</span>::<span class="ident">Zeroize</span>;

<span class="comment">// This struct will be zeroized on drop</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Zeroize</span>)]</span>
<span class="kw">struct</span> <span class="ident">MyStruct</span>([<span class="ident">u8</span>; <span class="number">64</span>]);</pre></div>
<p>If, for some reason, you only want <code>Zeroize</code> to be derived but <em>don't</em>
want an automatic <code>Drop</code> impl, you can add the <code>zeroize(no_drop)</code>
attribute:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">zeroize</span>::<span class="ident">Zeroize</span>;

<span class="comment">// This struct will *NOT* be zeroized on drop</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Zeroize</span>)]</span>
<span class="attribute">#[<span class="ident">zeroize</span>(<span class="ident">no_drop</span>)]</span>
<span class="kw">struct</span> <span class="ident">MyStruct</span>([<span class="ident">u8</span>; <span class="number">64</span>]);</pre></div>
<p>If you prefer explicitness, you can add the <code>#[zeroize(drop)]</code>
attribute to signal intent to zeroize values on <code>Drop</code>. However note this
syntax is not necessary as the <code>Drop</code> handler is added by default:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">zeroize</span>::<span class="ident">Zeroize</span>;

<span class="comment">// This struct will be zeroized on drop</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Zeroize</span>)]</span>
<span class="attribute">#[<span class="ident">zeroize</span>(<span class="ident">drop</span>)]</span>
<span class="kw">struct</span> <span class="ident">MyStruct</span>([<span class="ident">u8</span>; <span class="number">64</span>]);</pre></div>
<h2 id="zeroizingz-wrapper-for-zeroizing-arbitrary-values-on-drop" class="section-header"><a href="#zeroizingz-wrapper-for-zeroizing-arbitrary-values-on-drop"><code>Zeroizing&lt;Z&gt;</code>: wrapper for zeroizing arbitrary values on drop</a></h2>
<p><code>Zeroizing&lt;Z: Zeroize&gt;</code> is a generic wrapper type that impls <code>Deref</code>
and <code>DerefMut</code>, allowing access to an inner value of type <code>Z</code>, and also
impls a <code>Drop</code> handler which calls <code>zeroize()</code> on its contents:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">zeroize</span>::<span class="ident">Zeroizing</span>;

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">secret</span> <span class="op">=</span> <span class="ident">Zeroizing</span>::<span class="ident">new</span>([<span class="number">0u8</span>; <span class="number">5</span>]);

    <span class="comment">// Set the air shield password</span>
    <span class="comment">// Protip (again): don&#39;t embed secrets in your source code.</span>
    <span class="ident">secret</span>.<span class="ident">copy_from_slice</span>(<span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">secret</span>.<span class="ident">as_ref</span>(), <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);

    <span class="comment">// The contents of `secret` will be automatically zeroized on drop</span>
}</pre></div>
<h2 id="what-guarantees-does-this-crate-provide" class="section-header"><a href="#what-guarantees-does-this-crate-provide">What guarantees does this crate provide?</a></h2>
<p>Ideally a secure memory-zeroing function would guarantee the following:</p>
<ol>
<li>Ensure the zeroing operation can't be &quot;optimized away&quot; by the compiler.</li>
<li>Ensure all subsequent reads to the memory following the zeroing operation
will always see zeroes.</li>
</ol>
<p>This crate guarantees #1 is true: LLVM's volatile semantics ensure it.</p>
<p>The story around #2 is much more complicated. In brief, it should be true
that LLVM's current implementation does not attempt to perform
optimizations which would allow a subsequent (non-volatile) read to see the
original value prior to zeroization. However, this is not a guarantee, but
rather an LLVM implementation detail, a.k.a. <em>undefined behavior</em>.
It provides what we believe to be the best implementation possible on
stable Rust, but we cannot yet make guarantees it will work reliably
100% of the time (particularly on exotic CPU architectures).</p>
<p>For more background, we can look to the <a href="https://doc.rust-lang.org/core/ptr/fn.write_volatile.html">core::ptr::write_volatile</a>
documentation:</p>
<blockquote>
<p>Volatile operations are intended to act on I/O memory, and are guaranteed
to not be elided or reordered by the compiler across other volatile
operations.</p>
<p>Memory accessed with <code>read_volatile</code> or <code>write_volatile</code> should not be
accessed with non-volatile operations.</p>
</blockquote>
<p>Uhoh! This crate does not guarantee all reads to the memory it operates on
are volatile, and the documentation for <a href="https://doc.rust-lang.org/core/ptr/fn.write_volatile.html">core::ptr::write_volatile</a>
explicitly warns against mixing volatile and non-volatile operations.
Perhaps we'd be better off with something like a <code>VolatileCell</code>
type which owns the associated data and ensures all reads and writes are
volatile so we don't have to worry about the semantics of mixing volatile and
non-volatile accesses.</p>
<p>While that's a strategy worth pursuing (and something we may investigate
separately from this crate), it comes with some onerous API requirements:
it means any data that we might ever desire to zero is owned by a
<code>VolatileCell</code>. However, this does not make it possible for this crate
to act on references, which severely limits its applicability. In fact
a <code>VolatileCell</code> can only act on values, i.e. to read a value from it,
we'd need to make a copy of it, and that's literally the opposite of
what we want.</p>
<p>It's worth asking what the precise semantics of mixing volatile and
non-volatile reads actually are, and whether a less obtrusive API which
can act entirely on mutable references is possible, safe, and provides the
desired behavior.</p>
<p>Unfortunately, that's a tricky question, because
<a href="https://github.com/nikomatsakis/rust-memory-model">Rust does not have a formally defined memory model</a>,
and the behavior of mixing volatile and non-volatile memory accesses is
therefore not rigorously specified and winds up being an LLVM
implementation detail. The semantics were discussed extensively in this
thread, specifically in the context of zeroing secrets from memory:</p>
<p><a href="https://internals.rust-lang.org/t/volatile-and-sensitive-memory/3188/24">https://internals.rust-lang.org/t/volatile-and-sensitive-memory/3188/24</a></p>
<p>Some notable details from this thread:</p>
<ul>
<li>Rust/LLVM's notion of &quot;volatile&quot; is centered around data <em>accesses</em>, not
the data itself. Specifically it maps to flags in LLVM IR which control
the behavior of the optimizer, and is therefore a bit different from the
typical C notion of &quot;volatile&quot;.</li>
<li>As mentioned earlier, LLVM does not presently contain optimizations which
would reorder a non-volatile read to occur before a volatile write.
However, there is nothing precluding such optimizations from being added.
LLVM presently appears to exhibit the desired behavior for point
#2 above, but there is nothing preventing future versions of Rust
and/or LLVM from changing that.</li>
</ul>
<p>To help mitigate concerns about reordering potentially exposing values
after they have been zeroed, this crate leverages the <a href="https://doc.rust-lang.org/stable/core/sync/atomic/index.html">core::sync::atomic</a>
memory fence functions including <a href="https://doc.rust-lang.org/stable/core/sync/atomic/fn.compiler_fence.html">compiler_fence</a> and <a href="https://doc.rust-lang.org/stable/core/sync/atomic/fn.fence.html">fence</a> (which uses
the CPU's native fence instructions). These fences are leveraged with the
strictest ordering guarantees, <a href="https://doc.rust-lang.org/std/sync/atomic/enum.Ordering.html#variant.SeqCst">Ordering::SeqCst</a>, which ensures no
accesses are reordered. Without a formally defined memory model we can't
guarantee these will be effective, but we hope they will cover most cases.</p>
<p>Concretely the threat of leaking &quot;zeroized&quot; secrets (via reordering by
LLVM and/or the CPU via out-of-order or speculative execution) would
require a non-volatile access to be reordered ahead of the following:</p>
<ol>
<li>before an <a href="https://doc.rust-lang.org/std/sync/atomic/enum.Ordering.html#variant.SeqCst">Ordering::SeqCst</a> compiler fence</li>
<li>before an <a href="https://doc.rust-lang.org/std/sync/atomic/enum.Ordering.html#variant.SeqCst">Ordering::SeqCst</a> runtime fence</li>
<li>before a volatile write</li>
</ol>
<p>This seems unlikely, but our usage of mixed non-volatile and volatile
accesses is technically undefined behavior, at least until guarantees
about this particular mixture of operations is formally defined in a
Rust memory model.</p>
<p>Furthermore, given the recent history of microarchitectural attacks
(Spectre, Meltdown, etc), there is also potential for &quot;zeroized&quot; secrets
to be leaked through covert channels (e.g. memory fences have been used
as a covert channel), so we are wary to make guarantees unless they can
be made firmly in terms of both a formal Rust memory model and the
generated code for a particular CPU architecture.</p>
<p>In conclusion, this crate guarantees the zeroize operation will not be
elided or &quot;optimized away&quot;, makes a &quot;best effort&quot; to ensure that
memory accesses will not be reordered ahead of the &quot;zeroize&quot; operation,
but <strong>cannot</strong> yet guarantee that such reordering will not occur.</p>
<p>In the future it might be possible to guarantee such behavior using
<a href="https://llvm.org/docs/Atomics.html#unordered">LLVM's &quot;unordered&quot; atomic mode</a>, which is documented as
being free of undefined behavior. There's an open issue to
<a href="https://github.com/rust-lang/rust/issues/58599">expose atomic memcpy/memset in core/std</a>
in which case this crate could leverage them to provide well-defined
guarantees that zeroization will always occur.</p>
<h2 id="stackheap-zeroing-notes" class="section-header"><a href="#stackheap-zeroing-notes">Stack/Heap Zeroing Notes</a></h2>
<p>This crate can be used to zero values from either the stack or the heap.</p>
<p>However, be aware several operations in Rust can unintentionally leave
copies of data in memory. This includes but is not limited to:</p>
<ul>
<li>Moves and <code>Copy</code></li>
<li>Heap reallocation when using <code>Vec</code> and <code>String</code></li>
<li>Borrowers of a reference making copies of the data</li>
</ul>
<p><a href="https://doc.rust-lang.org/std/pin/struct.Pin.html"><code>Pin</code></a> can be leveraged in conjunction with this crate to ensure
data kept on the stack isn't moved.</p>
<p>The <code>Zeroize</code> impls for <code>Vec</code> and <code>String</code> zeroize the entire capacity of
their backing buffer, but cannot guarantee copies of the data were not
previously made by buffer reallocation. It's therefore important when
attempting to zeroize such buffers to initialize them to the correct
capacity, and take care to prevent subsequent reallocation.</p>
<p>This crate does not intend to implement higher-level abstractions to
eliminate these risks, instead it merely makes a best effort to clear the
memory it's aware of.</p>
<p>Crates which are built on <code>zeroize</code> and provide higher-level abstractions
for strategically avoiding these problems would certainly be interesting!
(and something we may consider developing in the future)</p>
<h2 id="what-about-clearing-registers-mlock-mprotect-etc" class="section-header"><a href="#what-about-clearing-registers-mlock-mprotect-etc">What about: clearing registers, mlock, mprotect, etc?</a></h2>
<p>This crate is laser-focused on being a simple, unobtrusive crate for zeroing
memory in as reliable a manner as is possible on stable Rust.</p>
<p>Clearing registers is a difficult problem that can't easily be solved by
something like a crate, and requires either inline ASM or rustc support.
See <a href="https://github.com/rust-lang/rust/issues/17046">https://github.com/rust-lang/rust/issues/17046</a> for background on
this particular problem.</p>
<p>Other memory protection mechanisms are interesting and useful, but often
overkill (e.g. defending against RAM scraping or attackers with swap access).
In as much as there may be merit to these approaches, there are also many
other crates that already implement more sophisticated memory protections.
Such protections are explicitly out-of-scope for this crate.</p>
<p>Zeroing memory is <a href="https://cryptocoding.net/index.php/Coding_rules#Clean_memory_of_secret_data">good cryptographic hygiene</a> and this crate seeks to promote
it in the most unobtrusive manner possible. This includes omitting complex
<code>unsafe</code> memory protection systems and just trying to make the best memory
zeroing crate available.</p>
</div><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.Zeroizing.html" title='zeroize::Zeroizing struct'>Zeroizing</a></td><td class='docblock-short'><p><code>Zeroizing</code> is a a wrapper for any <code>Z: Zeroize</code> type which implements a
<code>Drop</code> handler which zeroizes dropped values.</p>
</td></tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table><tr class='module-item'><td><a class="trait" href="trait.DefaultIsZeroes.html" title='zeroize::DefaultIsZeroes trait'>DefaultIsZeroes</a></td><td class='docblock-short'><p>Marker trait for types whose <code>Default</code> is the desired zeroization result</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.Zeroize.html" title='zeroize::Zeroize trait'>Zeroize</a></td><td class='docblock-short'><p>Trait for securely erasing types from memory</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "zeroize";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>